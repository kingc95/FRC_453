package frc.robot.commands;

import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj2.command.Subsystem;
import frc.robot.Constants;
import frc.robot.Constants.DriveConstants;
import frc.robot.subsystems.Drivetrain;
import frc.robot.subsystems.Climber;
import frc.robot.commands.*;
import frc.robot.Constants.*;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DigitalOutput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.RobotContainer;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

public class AutoClimb extends CommandBase{
    @SuppressWarnings({"PMD.UnusedPrivateField", "PMD.SingularField"})
    private final Drivetrain m_Drivetrain;
    private boolean barSelect;
    private final Climber m_Climber;

    private final Joystick driver = new Joystick(OIConstants.kDriverControllerPort);
  

    /**
     * Creates a new AutoClimb.
     *
     * @param subsystem The subsystem used by this command.
     */
  
     public AutoClimb(Drivetrain subsystem1, Climber subsystem2, boolean lowBar){
        m_Drivetrain = subsystem1;
        m_Climber = subsystem2;
        barSelect = lowBar; //true == low, false == high
     }
    // Called when the command is initially scheduled.
    @Override
    public void initialize() {}
  
    public void zeroClimber(){
        while(m_Climber.lowerLimit.get() == true){
            m_Climber.climberMotor.set(ControlMode.PercentOutput, ClimberConstants.climberSpeed);
            m_Drivetrain.drive(driver.getX(), driver.getY(), driver.getZ(), false, false);
        }
        m_Climber.climberMotor.set(ControlMode.PercentOutput, 0);
    }
    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        if(barSelect){
            m_Climber.goalMet.set(true);
            zeroClimber();
            while(m_Climber.climbEncoder.getRaw() < ClimberConstants.kLowBarTicks){
                m_Climber.climberMotor.set(ControlMode.PercentOutput, -ClimberConstants.climberSpeed);
                System.out.print("This is working");
                m_Drivetrain.drive(driver.getX(), driver.getY(), driver.getZ(), false, false);
            }
            m_Climber.climberMotor.set(ControlMode.PercentOutput, 0);
            m_Climber.goalMet.set(false);
        }
        else{
            m_Climber.goalMet.set(true);
            zeroClimber();
            while(m_Climber.climbEncoder.getRaw() < ClimberConstants.kMedBarTicks){
                m_Climber.climberMotor.set(ControlMode.PercentOutput, -ClimberConstants.climberSpeed);
                m_Drivetrain.drive(driver.getX(), driver.getY(), driver.getZ(), false, false);
            }
            m_Climber.climberMotor.set(ControlMode.PercentOutput, 0);
            m_Climber.goalMet.set(false);
        }
    }
  
    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {}
  
    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
      return false;
    }
}